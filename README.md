# Protein-Digest-Project
'Spliceapp' is a simple web application I created, which takes a protein sequence, "splices" it into fragments, and displays the fragments neatly in a table. It does so according to the rules of a selected enzyme, and also editting the results based on user inputs: a. The number of "missed cleavages" which is acceptable. and: b. Legnth and weight restrictions for the resulting fragments.

This folder contains the zipped complete application, which runs on TurboGears. Hence, I ran it from the commandline, using the 'tgserve' command. The folder also contains the salient modules that I spent most of my time working on: 'splicemod.py' and 'spliceapp.py'. It also contains the modified index and root files, and the 'dice.html' template. I can't claim to be an expert in web development, and must admit that I leaned heavily on course materials for this portion of the project, but the modules executing the actual "work" were planned and executed independently.

Workflow: 

1. The work of actually generating the table is done by 'Splice_Mod.py'. This is where object oriented programming and inheritance comes in. Given that all the splicing enzymes do more-or-less the same thing, but with different inputs (the instructions as to where to make "cuts"), they can all simply inherit these methods from a single parent class.
The parent class is 'Splice_Prot', which accepts all the relevant user inputs in its '__init__' method (the sequence to be spliced, min/max legnth and weight, and finally the missed cleavages condition), all with default values. It does not accept the information of which enzyme to use, because each enzyme is a separate child class. Finally, the 'splice_list' in this parent class only contains '0', the begining of the sequence. No actual splice sites.
a. The 'full_list' method adds to the 'splice_list' the end of the sequence. The result is a simple list of all the "milestones"  in the sequence (start, (splice sites), end). It then generates and outputs a list of pairs, using the missed cleavages condition. These pairs represent the start and end points of all possible fragments generated. Together with the actual AA sequence, they are really all the information required to generate the table of fragments.
b. The 'LW_table' method is fairly simple. It takes the list of "start-end" pairs generated by the previous method, and fills out a table of information, row-by-row. When the individual row is complete, the decision on whether to add it to the table is taken, based on the legnth and weight criteria given by the user. Finally, the completed table is returned.

Comment: My first version of this module did all of the above in a must more complicated way. I only realized that there was a better (and more logical) way to do things when I was finished.

2. Child classes inherit the 'full_list' and 'LW_table' methods, and feed into them a different '__init__' method. In this method, each of the enzymes accepts all the same inputs as before, but builds out the 'splice_list' according to the logic of the actual enzyme its tasked with emulating. This list then goes into the afforementioned pipeline.

3. 'Splice_App.py' is a much simpler module. It simply accepts all the relevant user input, this time also accepting the name of the enzyme to be used, and then accesses the appropriate enzyme (child class) from 'Splice_Mod'. The information is fed in, and the table of splices retrieved.

4. The remaining files simply connect 'Splice_App.py' and 'Splice_Mod.py' to the web application, allowing users to manually input their arguments through a form, and allowing the resulting table to be displayed. Currently there are no input validations, which would be an issue for real usage, but otherwhise, it's enough to get the job done.
